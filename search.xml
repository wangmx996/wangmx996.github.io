<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SpringCloud学习笔记：（六）Config分布式配置中心</title>
      <link href="/2020/06/20/spring/springcloud/springcloud-xue-xi-bi-ji-liu-config-fen-bu-shi-pei-zhi-zhong-xin/"/>
      <url>/2020/06/20/spring/springcloud/springcloud-xue-xi-bi-ji-liu-config-fen-bu-shi-pei-zhi-zhong-xin/</url>
      
        <content type="html"><![CDATA[<h2 id="Config分布式配置中心介绍"><a href="#Config分布式配置中心介绍" class="headerlink" title="Config分布式配置中心介绍"></a>Config分布式配置中心介绍</h2><p>Spring Cloud Config为分布式系统中的外部化配置提供服务器端和客户端支持，配置服务器为各个不同微服务应用的所有环境提供了一个中心化的外部配置<br>Spring Cloud Config分为服务端和客户端两个部分</p><h2 id="Config分布式配置中心搭建"><a href="#Config分布式配置中心搭建" class="headerlink" title="Config分布式配置中心搭建"></a>Config分布式配置中心搭建</h2><h2 id="Config客户端配置"><a href="#Config客户端配置" class="headerlink" title="Config客户端配置"></a>Config客户端配置</h2>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> Config </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot入门到精通：（二）启动原理解析</title>
      <link href="/2020/06/14/spring/springboot/springboot-ru-men-dao-jing-tong-er-qi-dong-yuan-li-jie-xi/"/>
      <url>/2020/06/14/spring/springboot/springboot-ru-men-dao-jing-tong-er-qi-dong-yuan-li-jie-xi/</url>
      
        <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20191013195748147.png" alt="在这里插入图片描述"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面见识了SpringBoot为我们做的自动配置，非常方便快捷，相比于之前繁琐的配置文件，简直不要太优秀，让我们不禁好奇，到底是怎么做到的呢，让我们一起来探究一下</p><hr><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>我们开发任何一个Spring Boot项目，都会用到如下的启动类</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Application</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>Application<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>从上面代码可以看出，Annotation定义（@SpringBootApplication）和类定义（SpringApplication.run）最为耀眼，所以要揭开SpringBoot的神秘面纱，我们要从这两位开始就可以了。</p><p>@<strong>SpringBootApplication</strong>:    Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；<br>看一下他的源码：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Inherited</span><span class="token annotation punctuation">@SpringBootConfiguration</span><span class="token annotation punctuation">@EnableAutoConfiguration</span><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>excludeFilters <span class="token operator">=</span> <span class="token punctuation">{</span>      <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span>type <span class="token operator">=</span> FilterType<span class="token punctuation">.</span>CUSTOM<span class="token punctuation">,</span> classes <span class="token operator">=</span> TypeExcludeFilter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span>type <span class="token operator">=</span> FilterType<span class="token punctuation">.</span>CUSTOM<span class="token punctuation">,</span> classes <span class="token operator">=</span> AutoConfigurationExcludeFilter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">SpringBootApplication</span> <span class="token punctuation">{</span></code></pre><p>SpringBootApplication是一个组合注解，虽然定义使用了多个Annotation进行了原信息标注，但重要的只有三个Annotation：</p><ul><li>@SpringBootConfiguration</li><li>@EnableAutoConfiguration</li><li>@ComponentScan</li></ul><p>所以，如果我们使用如下的SpringBoot启动类，整个SpringBoot应用依然可以与之前的启动类功能对等：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@EnableAutoConfiguration</span><span class="token annotation punctuation">@ComponentScan</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Application</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>Application<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>每次写这3个比较累，所以写一个@SpringBootApplication方便点。接下来分别介绍这3个Annotation。</p><h3 id="1-SpringBootConfiguration-Spring-Boot的配置类；"><a href="#1-SpringBootConfiguration-Spring-Boot的配置类；" class="headerlink" title="1. @SpringBootConfiguration:Spring Boot的配置类；"></a>1. @<strong>SpringBootConfiguration</strong>:Spring Boot的配置类；</h3><p>​        标注在某个类上，表示这是一个Spring Boot的配置类；</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">SpringBootConfiguration</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>​@Configuration对我们来说不陌生，它就是JavaConfig形式的Spring Ioc容器的配置类使用的那个@Configuration，SpringBoot社区推荐使用基于JavaConfig的配置形式，所以，这里的启动类标注了@Configuration之后，本身其实也是一个IoC容器的配置类。配置类也是容器中的一个组件；@Component</p><p>举几个简单例子回顾下，XML跟config配置方式的区别：</p><p>表达形式层面<br>基于XML配置的方式是这样：</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd<span class="token punctuation">"</span></span>       <span class="token attr-name">default-lazy-init</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--bean定义--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span></code></pre><p>而基于JavaConfig的配置方式是这样：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MockConfiguration</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//bean定义</span><span class="token punctuation">}</span></code></pre><p>任何一个标注了@Configuration的Java类定义都是一个JavaConfig配置类。</p><p>注册bean定义层面<br>基于XML的配置形式是这样：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>userService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>..UserServiceImpl<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    ...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre><p>而基于JavaConfig的配置形式是这样的：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringConfiguration</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> UserService <span class="token function">userService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">UserServiceImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>任何一个标注了@Bean的方法，其返回值将作为一个bean定义注册到Spring的IoC容器，方法名将默认成该bean定义的id。</p><p>表达依赖注入关系层面<br>为了表达bean与bean之间的依赖关系，在XML形式中一般是这样：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mockService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>..MockServiceImpl<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    &lt;propery name ="dependencyService" ref="dependencyService" /><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dependencyService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>DependencyServiceImpl<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre><p>而基于JavaConfig的配置形式是这样的：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringConfiguration</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> UserService <span class="token function">userService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">UserServiceImpl</span><span class="token punctuation">(</span><span class="token function">dependencyService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> DependencyService <span class="token function">dependencyService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DependencyServiceImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>如果一个bean的定义依赖其他bean,则直接调用对应的JavaConfig类中依赖bean的创建方法就可以了。</p><hr><h3 id="2-ComponentScan：开启自动配置功能；"><a href="#2-ComponentScan：开启自动配置功能；" class="headerlink" title="2. @ComponentScan：开启自动配置功能；"></a>2. @<strong>ComponentScan</strong>：开启自动配置功能；</h3><p>@ComponentScan这个注解在Spring中很重要，它对应XML配置中的元素，@ComponentScan的功能其实就是自动扫描并加载符合条件的组件（比如@Component和@Repository等）或者bean定义，最终将这些bean定义加载到IoC容器中。</p><p>我们可以通过basePackages等属性来细粒度的定制@ComponentScan自动扫描的范围，如果不指定，则默认Spring框架实现会从声明@ComponentScan所在类的package进行扫描。</p><p><strong>注</strong>：所以SpringBoot的启动类最好是放在root package下，因为默认不指定basePackages。</p><h3 id="3-EnableAutoConfiguration：开启自动配置功能；"><a href="#3-EnableAutoConfiguration：开启自动配置功能；" class="headerlink" title="3. @EnableAutoConfiguration：开启自动配置功能；"></a>3. @<strong>EnableAutoConfiguration</strong>：开启自动配置功能；</h3><p>SpringBoot之所以可以零配置，其核心就是​@EnableAutoConfiguration这个Annotation，以前我们需要配置的东西，Spring Boot帮我们自动配置；而@<strong>EnableAutoConfiguration</strong>告诉SpringBoot开启自动配置功能；这样自动配置才能生效；<br>大家是否还记得Spring框架提供的各种名字为@Enable开头的Annotation定义？比如@EnableScheduling、@EnableCaching、@EnableMBeanExport等，@EnableAutoConfiguration的理念和做事方式其实一脉相承<br>简单概括一下就是，借助<strong>@Import的支持，收集和注册特定场景相关的bean定义</strong>。<br>@EnableScheduling是通过@Import将Spring调度框架相关的bean定义都加载到IoC容器。<br>@EnableMBeanExport是通过@Import将JMX相关的bean定义加载到IoC容器。<br>而@EnableAutoConfiguration也是借助@Import的帮助，将所有符合自动配置条件的bean定义加载到IoC容器，仅此而已！</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@AutoConfigurationPackage</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span>EnableAutoConfigurationImportSelector<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">EnableAutoConfiguration</span> <span class="token punctuation">{</span></code></pre><p>​          @<strong>AutoConfigurationPackage</strong>：自动配置包</p><p>​        @<strong>Import</strong>(AutoConfigurationPackages.Registrar.class)：</p><p>​        Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class==将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；==</p><p>​        @<strong>Import</strong>(EnableAutoConfigurationImportSelector.class)；</p><p>​        给容器中导入组件？</p><p>​        <strong>EnableAutoConfigurationImportSelector</strong>：导入哪些组件的选择器；</p><p>​        将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中；</p><p>​        会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件；<br><img src="https://img-blog.csdnimg.cn/2019101419355125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>有了自动配置类，免去了我们手动编写配置注入功能组件等的工作；<br>借助于Spring框架原有的一个工具类：SpringFactoriesLoader的支持，SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)；Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；以前我们需要自己配置的东西，自动配置类都帮我们；</p><p><img src="https://img-blog.csdnimg.cn/20191014200657927.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191014200702151.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191014200723840.png" alt="在这里插入图片描述"><br>J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure中</p><p><img src="https://img-blog.csdnimg.cn/20191014195708246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot入门到精通：（一）Hello World</title>
      <link href="/2020/06/14/spring/springboot/springboot-ru-men-dao-jing-tong-yi-hello-world/"/>
      <url>/2020/06/14/spring/springboot/springboot-ru-men-dao-jing-tong-yi-hello-world/</url>
      
        <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20191013182144841.png" alt="在这里插入图片描述"></p><h2 id="Spring-Boot-概述"><a href="#Spring-Boot-概述" class="headerlink" title="Spring Boot 概述"></a>Spring Boot 概述</h2><blockquote><p><strong>Build Anything with Spring Boot：</strong><br>Spring Boot is the starting point for building all Spring-based applications. Spring Boot is designed to get you up and running as quickly as possible, with minimal upfront configuration of Spring.</p></blockquote><p>上面是引自官网的一段话，大概是说： Spring Boot 是所有基于 Spring 开发的项目的起点。Spring Boot 的设计是为了让你尽可能快的跑起来 Spring 应用程序并且尽可能减少你的配置文件。<br><img src="https://img-blog.csdnimg.cn/20191014202643364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在SpringBoot官方网站上，介绍了SpringBoot的特点<br>就是快速简洁的创建独立的Spring应用程序，并且完全不需要任何配置文件<br>它使用 “习惯优于配置” （项目中存在大量的配置，此外还内置一个习惯性的配置，让你无须）的理念让你的项目快速运行起来。<br>它并不是什么新的框架，而是默认配置了很多框架的使用方式，就像 Maven 整合了所有的 jar 包一样，Spring Boot 整合了所有框架</p><h2 id="SpringBoot快速搭建"><a href="#SpringBoot快速搭建" class="headerlink" title="SpringBoot快速搭建"></a>SpringBoot快速搭建</h2><p>第一步：新建项目<br>选择 Spring Initializr ，然后选择默认的 url 点击【Next】：<br><img src="https://img-blog.csdnimg.cn/20191013182424420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后修改一下项目的信息：<br><img src="https://img-blog.csdnimg.cn/2019101318255057.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>勾选项目需要的模块<br><img src="https://img-blog.csdnimg.cn/20191013182649432.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>选择项目路径，修改项目名，点击Finish<br><img src="https://img-blog.csdnimg.cn/20191013182748525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>至此，项目创建完成，项目结构如下<br><img src="https://img-blog.csdnimg.cn/20191013183132126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>DemoApplication： 一个带有 main() 方法的类，用于启动应用程序</li><li>DemoApplicationTests：一个空的 Junit 测试了，它加载了一个使用 Spring Boot 字典配置功能的  Spring 应用程序上下文</li><li>resource文件夹目录结构<ul><li>static：用于存储静态文件（css,js等）</li><li>templates：用于存放模板页面</li><li>application.properties：SpringBoot应用的配置文件，可以用来修改一些默认配置</li></ul></li><li>pom.xml： Maven 构建说明文件</li></ul><p>第一步：Hello World<br>在【cn.example.demo】包下新建一个package【controller】，新建类【HelloWorldController】：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloWorldController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Hello World !!!"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>第三步：利用 IDEA 启动 Spring Boot<br>我们回到 DemoApplication 这个类中，然后右键点击运行：<br><img src="https://img-blog.csdnimg.cn/2019101318443227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><strong>注意</strong>：我们之所以在上面的项目中没有手动的去配置 Tomcat 服务器，是因为 Spring Boot 内置了 Tomcat<br>启动成功<br><img src="https://img-blog.csdnimg.cn/2019101318460481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以看到我们的 Tomcat 运行在 8080 端口，我们来访问 “/hello” 地址试一下：<br><img src="https://img-blog.csdnimg.cn/20191013184646707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>至此，一个SpringBoot的HelloWorld完成</li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker入门：（二）Docker介绍</title>
      <link href="/2020/06/14/docker/docker-ru-men-er-docker-jie-shao/"/>
      <url>/2020/06/14/docker/docker-ru-men-er-docker-jie-shao/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker概念"><a href="#Docker概念" class="headerlink" title="Docker概念"></a>Docker概念</h2><blockquote><p>Docker is a platform for developers and sysadmins to build, run, and share applications with containers. The use of containers to deploy applications is called containerization. Containers are not new, but their use for easily deploying applications is.</p></blockquote><p>上面是<a href="https://docs.docker.com/get-started/" target="_blank" rel="noopener">Docker官方文档</a>中给出的定义，翻译之后就是：<br>Docker是一个供开发人员和系统管理员使用容器构建、运行和共享应用程序的平台。使用容器部署应用程序称为容器化。容器并不新鲜，但它们用于轻松部署应用程序却很新鲜。</p><p>因此，要了解docker是什么，首先我们要理解<strong>容器</strong>的概念，而理解容器，我们还要了解<strong>容器</strong>和<strong>虚拟机</strong>的区别</p><h2 id="容器和虚拟机"><a href="#容器和虚拟机" class="headerlink" title="容器和虚拟机"></a>容器和虚拟机</h2><p>上文中我们介绍了虚拟化技术，了解了虚拟化架构之后，我们就可以很清楚的区分<strong>容器</strong>和<strong>虚拟机</strong>的概念<br>我们用的传统虚拟机如 VMware ， VisualBox 之类的是全虚拟化架构，需要模拟整台机器包括硬件，每台虚拟机都需要有自己的操作系统，虚拟机一旦被开启，预分配给它的资源将全部被占用。每一台虚拟机包括应用，必要的二进制和库，以及一个完整的用户操作系统。</p><p>而容器技术是基于操作系统层的虚拟化技术，容器和我们的宿主机共享硬件资源及操作系统，可以实现资源的动态分配。容器包含应用和其所有的依赖包，但是与其他容器共享内核。容器在宿主机操作系统中，在用户空间以分离的进程运行。</p><p>容器技术是实现操作系统虚拟化的一种途径，可以让您在资源受到隔离的进程中运行应用程序及其依赖关系。通过使用容器，我们可以轻松打包应用程序的代码、配置和依赖关系，将其变成容易使用的构建块，从而实现环境一致性、运营效率、开发人员生产力和版本控制等诸多目标。容器可以帮助保证应用程序快速、可靠、一致地部署，其间不受部署环境的影响。容器还赋予我们对资源更多的精细化控制能力，让我们的基础设施效率更高。通过下面这幅图我们可以很直观的反映出这两者的区别所在<br><img src="https://img-blog.csdnimg.cn/20200307215606288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>容器的优点：</p><ul><li><p><strong>灵活</strong>:即使是最复杂的应用程序也可以被封装。</p></li><li><p><strong>轻量级</strong>:容器利用和共享主机内核，使它们在系统资源方面比虚拟机更高效。</p></li><li><p><strong>可移植性</strong>:您可以在本地构建、部署到云，并在任何地方运行。</p></li><li><p><strong>松散耦合</strong>:容器是高度自给自足和封装的，允许您替换或升级一个容器而不破坏其他容器。</p></li><li><p><strong>可伸缩</strong>:您可以增加并自动跨数据中心分发容器副本。</p></li><li><p><strong>安全</strong>:容器对进程应用主动约束和隔离，而不需要用户进行任何配置。</p></li></ul><p>我们可以从下面这张表格很清楚地看到容器相比于传统虚拟机的特性的优势所在：<br>|特性  |容器  | 虚拟机|<br>|–|–|–|<br>|启动|    秒级    |分钟级|<br>|硬盘使用    |一般为MB|    一般为GB|<br>|性能|    接近原生|    弱于|<br>|系统支持量|    单机支持上千个容器|    一般是几十个|</p><h2 id="Docker定位"><a href="#Docker定位" class="headerlink" title="Docker定位"></a>Docker定位</h2><p>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离，相当于是在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。<br>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker ，就不用担心环境问题。<br>总体来说， Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p><p>Docker相比于传统虚拟化方式具有更多的优势：</p><ul><li>docker 启动快速属于秒级别。虚拟机通常需要几分钟去启动</li><li>docker 需要的资源更少， docker 在操作系统级别进行虚拟化， docker 容器和内核交互，几乎没有性能损耗，性能优于通过 Hypervisor 层与内核层的虚拟化</li><li>docker 更轻量， docker 的架构可以共用一个内核与共享应用程序库，所占内存极小。同样的硬件环境，  Docker 运行的镜像数远多于虚拟机数量，对系统的利用率非常高<br>与虚拟机相比， docker 隔离性更弱， docker 属于进程之间的隔离，虚拟机可实现系统级别隔离</li><li>安全性： docker 的安全性也更弱。 Docker 的租户 root 和宿主机 root 等同，一旦容器内的用户从普通用户权限提升为root权限，它就直接具备了宿主机的root权限，进而可进行无限制的操作。虚拟机租户 root 权限和宿主机的 root 虚拟机权限是分离的，并且虚拟机利用如 Intel 的 VT-d 和 VT-x 的 ring-1 硬件隔离技术，这种隔离技术可以防止虚拟机突破和彼此交互，而容器至今还没有任何形式的硬件隔离，这使得容器容易受到攻击</li><li>可管理性： docker 的集中化管理工具还不算成熟。各种虚拟化技术都有成熟的管理工具，例如 VMware vCenter 提供完备的虚拟机管理能力</li><li>高可用和可恢复性： docker 对业务的高可用支持是通过快速重新部署实现的。虚拟化具备负载均衡，高可用，容错，迁移和数据保护等经过生产实践检验的成熟保障机制， VMware 可承诺虚拟机 99.999% 高可用，保证业务连续性</li><li>快速创建、删除：虚拟化创建是分钟级别的， Docker 容器创建是秒级别的， Docker 的快速迭代性，决定了无论是开发、测试、部署都可以节约大量时间<br>交付、部署：虚拟机可以通过镜像实现环境交付的一致性，但镜像分发无法体系化。 Docker 在 Dockerfile 中记录了容器构建过程，可在集群中实现快速分发和快速部署</li></ul><h2 id="Docker三要素"><a href="#Docker三要素" class="headerlink" title="Docker三要素"></a>Docker三要素</h2><p><img src="https://img-blog.csdnimg.cn/2020030822421362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从上图我们可以看到，Docker 中包括三个基本的要素：</p><ol><li>Repository(仓库)</li><li>Image(镜像)</li><li>Container(容器)</li></ol><h3 id="Repository（仓库）"><a href="#Repository（仓库）" class="headerlink" title="Repository（仓库）"></a>Repository（仓库）</h3><p>仓库的概念很好理解，Docker 仓库是集中存放镜像文件的场所。如果使用了git和github就很容易理解docker的仓库概念。docker仓库概念和git类似。</p><p>docker提供了一个注册服务器（register）来保存多个仓库，每个仓库又可以包含多个具备不同tag的镜像，</p><p>docker运作中使用的默认仓库是<a href="https://hub.docker.com/" target="_blank" rel="noopener">docker hub</a>公共仓库。</p><p>仓库支持的操作类似git，当用户创建了自己的镜像之后就可以使用push命令将它上传到共有或者私有的仓库。这样下次再另外一台机器上使用这个镜像的时候只需要从仓库里面pull下来就可以了。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本 。我们可以通过&lt;仓库名&gt;:&lt;标签&gt;的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签.。</p><h3 id="Image-镜像-和Container-容器"><a href="#Image-镜像-和Container-容器" class="headerlink" title="Image(镜像)和Container(容器)"></a>Image(镜像)和Container(容器)</h3><p><img src="https://img-blog.csdnimg.cn/20200308223245737.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>Fundamentally, a container is nothing but a running process, with some added encapsulation features applied to it in order to keep it isolated from the host and from other containers. One of the most important aspects of container isolation is that each container interacts with its own private filesystem; this filesystem is provided by a Docker image. An image includes everything needed to run an application - the code or binary, runtimes, dependencies, and any other filesystem objects required.<br>容器只是一个正在运行的进程，为了使它与主机和其他容器隔离，在其上应用了一些附加的封装特性。容器隔离最重要的方面之一是每个容器都与自己的私有文件系统进行交互;此文件系统由Docker镜像提供。镜像包含运行应用程序所需的所有东西——代码或二进制文件、运行时、依赖项以及所需的任何其他文件系统对象。</p></blockquote><p>镜像是文件, 容器是进程。 容器是基于镜像创建的, 即容器中的进程依赖于镜像中的文件, 这里的文件包括进程运行所需要的可执行文件， 依赖软件， 库文件， 配置文件等等…<br>相对于镜像来说容器是动态的，容器的定义和镜像几乎一样，唯一的区别是容器在启动的时候创建了一层可写层次作为最上层。（   docker create &lt;image -id &gt; ：为指定的镜像添加一个可读写层，构成一个新的容器；）<br>==注：容器是由镜像实例化而来，这和我们学习的面向对象的概念十分相似，我们可以把镜像看作类，把容器看作类实例化后的对象。==<br>docker 的镜像概念类似虚拟机的镜像。是一个只读的模板，一个独立的文件系统，带有创建Docker容器的指令，可以用来创建新的容器。（  docker create &lt;image -id &gt; ：为指定的镜像添加一个可读写层，构成一个新的容器；）例如：一个镜像可以包含一个完整的ubuntu操作系统环境，里面仅安装了mysql或用户需要的其他应用程序。<br>docker镜像实际上是由一层一层的系统文件组成，这种层级的文件系统被称为UnionFS( Union file system  统一文件系统)，镜像可以基于dockerfile构建，dockerfile是一个描述文件，里面包含了若干条密令，每条命令都会对基础文件系统创建新的层次结构。</p><p>docker提供了一个很简单的机制来创建镜像或更新现有的镜像。用户甚至可以从其他人那里下载一个已经做好的镜像直接使用。（镜像是只读的，可以理解为静态文件）</p><p>docker利用容器来运行应用：docker容器是由docker镜像创建的运行实例。docker容器类似虚拟机，可以执行包含启动，停止，删除等。每个容器间是相互隔离的。容器中会运行特定的运用，包含特定应用的代码及所需的依赖文件。==可以把容器看作一个简易版的linux环境（包含root用户权限，进程空间，用户空间和网络空间等）和运行在其中的应用程序==。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
